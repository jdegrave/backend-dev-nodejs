## Strict Mode

#Example 1

This will work just fine in the sense that it won't throw an error. Hard to debug logic issues may arise as a result of the value of person not being appropriately set but we think we've done it correctly.
```js
var person;

// this is a typo where we try to set person equal to some value
persom = {name: 'Joe'};

// logging both to show what happens to the variables person and persom in our situation where we simulate a typo error
console.log(person);
console.log(persom);
```

Now an error will be thrown where we would otherwise accidentally create a new global variable.
```js
'use strict';

var person;

persom = {name: 'Joe'};

console.log(person);
console.log(persom);
```

#Example 2

Here, we specify to only use strict inside the logNewPerson function. The error that is thrown throws on the line where we try to use otherPersom instead of the line where we try to use persom.
```js
var person;
persom = {name: 'Joe'};

console.log('GLOBAL:');
console.log(person);
console.log(persom);

function logNewPerson() {
  'use strict';

  var otherPerson;
  otherPersom = {name: 'Jane'};
  console.log('FUNCTION:');
  console.log(otherPerson);
  console.log(otherPersom);
}

logNewPerson();
```

#Example 3
```js
var myObject = {};
Object.defineProperty(myObject, 'x', { value: 19, writable: false });
myObject.myProperty = 9;
console.log(myObject.myProperty);
```

```js
'use strict';
var myObject = {};
Object.defineProperty(myObject, 'x', { value: 19, writable: false });
myObject.myProperty = 9;
console.log(myObject.myProperty);
```

#Example 4
```js
'use strict';
delete Object.prototype;
```

#Example 5
```js
function sum(a, a, c) {
  return a + a + c;
}

console.log(sum(1, 2, 3));
```

```js
function sum(a, a, c) {
  'use strict';
  return a + a + c;
}

console.log(sum(1, 2, 3));
```


## Global

# Execution Context
Create index.html and app.js files, and open index.html file in the browser. Inspect the page to open up dev tools and go to the console. There, we can view this and window. We have these values despite having written no code in app.js - these are generated by the Javascript engine for us.

This code is global because it is not inside a function. Putting this code is app.js globally attaches them to the global function.
```js
var myVar = 'I am a string';

function myFunc () {
  console.log('I am a function');
};
```


## Function

# Execution Context

```js
function myFunc() {
  var myVar = 8;
  console.log('MY FUNC: ', myVar);
  myOtherFunc();
}

function myOtherFunc() {
  var myVar;
  console.log('MY OTHER FUNC: ', myVar);
}

var myVar = 3;
console.log('GLOBAL FIRST: ', myVar);
myFunc();
console.log('GLOBAL SECOND: ', myVar);
```


What happens when we remove the myVar delcaration from myOtherFunc?

```js
function myFunc() {
  var myVar = 8;
  console.log('MY FUNC: ', myVar);
  myOtherFunc();
}

function myOtherFunc() {
  console.log('MY OTHER FUNC: ',myVar);
}

var myVar = 3;
console.log('GLOBAL FIRST: ', myVar);
myFunc();
console.log('GLOBAL SECOND: ', myVar);
```


# Simple Call
```js
function simpleCall() {
  console.log('Simple Call This:');
  console.log(this);
}

function strictCall() {
  'use strict';
  console.log('Strict Call This:');
  console.log(this);
}

simpleCall();
strictCall();
```

# call and apply
```js
'use strict';

var a = 5;
var b = 6;

function add(c, d) {
  return this.a + this.b + c + d;
}

console.log(add.call(this, 3, 4));
console.log(add.apply(this, [7, 8]));
```

```js
'use strict';

var a = 5;
var b = 6;

var myObj = {
  a: 11,
  b: 15
};

function add(c, d) {
  return this.a + this.b + c + d;
}

console.log(add.call(myObj, 3, 4));
console.log(add.apply(myObj, [5, 6]));
```

# bind
```js
function myFunc() {
  return this.myProp;
}

var myObj = {
  myProp: 'I am another property'
}

var aFunc = myFunc.bind({myProp:'I am a property'});
var bFunc = myFunc.bind(myObj);

console.log(aFunc());
console.log(bFunc());
```

# this and Objects
```js
'use strict';

var myObject = {
  number: 4,
  getNumber: function() {
    return this.number;
  }
};

console.log(myObject.getNumber());
```

```js
'use strict';

var myObject = {
  number: 4,
};

function aNumberFunction () {
  return this.number;
}

myObject.getNumber = aNumberFunction;

console.log(myObject.getNumber());
```

```js
'use strict';

var person = {
  firstName: 'John',
  lastName: 'Doe',
  getFullName: function () {
    return this.firstName + ' ' + this.lastName;
  }
}

console.log(person.getFullName());
```


## Exercise

This code needs to be fixed
```js
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function(otherName) {
  return 'Hi ' + otherName + ', my name is ' + name;
}
```

Solution
```js
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function(otherName) {
  return 'Hi ' + otherName + ', my name is ' + this.name;
}
```
